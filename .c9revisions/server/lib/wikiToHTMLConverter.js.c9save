{"ts":1379346293595,"silentsave":true,"restoring":false,"patch":[[]],"length":0}
{"contributors":[],"silentsave":false,"ts":1379346300332,"patch":[[{"diffs":[[1,"var constants = require(\"wikiConstants\");\n\nvar STRONG_EM_STYLE_REGEX = /[']{5}\\s*([^']+'[^']+|[^']*)\\s*[']{5}/g;\nvar STRONG_STYLE_REGEX = /[']{3}\\s*([^']+'[^']+|[^']*)\\s*[']{3}/g;\nvar EM_STYLE_REGEX = /[']{2}\\s*([^']+'[^']+|[^']*)\\s*[']{2}/g;\nvar HEADING_REGEX = /^=+([^=]*).*$/g;\nvar SINGLE_BRACKET_LINK_REGEX = /\\[([^\\]]*)\\]/g;\nvar LINK_REGEX = /\\[\\[([^\\]]*)\\]\\]/g;\nvar CITATION_REFERENCE_REGEX = /\\{\\{Cite\\s*([^\\}]*)\\}\\}/gi;\nvar GUTENBERG_REFERENCE_REGEX = /\\{\\{Gutenberg\\s*([^\\}]*)\\}\\}/gi;\nvar WORLDCAT_REFERENCE_REGEX = /\\{\\{worldcat\\s*([^\\}]*)\\}\\}/gi;\nvar SPECIAL_LANGUAGE_INFO_REGEX = /\\{\\{([^\\}]*)\\}\\}/g;\nvar REFERENCE_REGEX = /<ref\\s*name=\"([^\"]*)\"\\s*\\/?>[^<]*(<\\/ref>)?/g;\nvar REFERENCES_TO_IGNORE = /<ref[^\\/]*\\/>|<ref[^>]*>[^<]*<\\/ref>/g;\nvar COMMENTS_REGEX = /<!--\\s*[^-]*-->/g;\n\nvar LANGUAGE_MAP = {\n  \"lang-fr\": \"French\",\n  \"lang-es\": \"Spanish\",\n  \"lang-en\": \"English\",\n  \"lang-it\": \"Italian\"\n};\n\nfunction convertLineToHTML(line) {\n  var matched = false;\n\n  line = line.replace(CITATION_REFERENCE_REGEX, function (match, matchedSequence) {\n    var sections = matchedSequence.split(\"|\");\n    var refType = sections.shift();\n    var tile = \"\";\n    var elem = '<span class=\"reference\" data-type=\"' + refType + '\"';\n    sections.forEach(function (section) {\n      var keyValue = section.split(\"=\");\n      if (keyValue[0] !== \"title\") {\n        elem += ' data-' + keyValue[0] + '=\"' + keyValue[1] + '\"';\n      }else{\n        tile = keyValue[1];\n      }\n    });\n\n    elem += \">\" + tile + \"</span>\";\n    matched = true;\n    return elem;\n  });\n\n// if(matched){\n// //Short-circuit here, since we have matched a reference\n// return line;\n// }\n\n  line = line.replace(GUTENBERG_REFERENCE_REGEX, function(match, matchedSequence){\n  // e.g. {Gutenberg|no=3567|name=Memoirs of Napoleon}}\n    var sections = matchedSequence.split(\"|\");\n    //Get rid of the \"Gutenberg\"\n    sections.shift();\n    var gutenbergNb = 0;\n    var title = \"\";\n    sections.forEach(function(section){\n      var keyValue = section.split(\"=\");\n      if(keyValue[0] === \"name\"){\n        title = keyValue[1];\n      }else if(keyValue[0] === \"no\"){\n        gutenbergNb = keyValue[1];\n      }\n    });\n    matched = true;\n\n    return '<a href=\"' + constants.PROJECT_GUTENBERG_EBOOK_BASE_URL + gutenbergNb + '\">' + title + \"</a>\";\n  });\n\n// if(matched){\n// return line;\n// }\n\n  line = line.replace(WORLDCAT_REFERENCE_REGEX, function(natch, matchedSequence){\n    // e.g. {{worldcat id|id=lccn-n79-54933}}\n    var idIndex = matchedSequence.indexOf(\"id=\");\n    var id = matchedSequence.substring(idIndex + 3);\n\n    matched = true;\n    return '<a href=\"' + constants.WORLDCAT_IDENTITY_LINK + id + '\">Worldcat reference</a>';\n  });\n\n// if(matched){\n// return line;\n// }\n\n\n\n\n  line = line.replace(HEADING_REGEX, function (match, subMatch1) {\n    var index = match.indexOf(subMatch1);\n    var lastIndex = match.length - index;\n    var headingTag = \"h\" + index;\n    return \"<\" + headingTag + \">\" + match.substring(index, lastIndex) + \"</\" + headingTag + \">\";\n  });\n\n  // cascading order of quote matching such that we don't match a lesser number\n  // of quotes inside a larger number\n  line = line.replace(STRONG_EM_STYLE_REGEX, function (match, subMatch1) {\n    return \"<strong><em>\" + subMatch1 + \"</em></strong>\";\n  });\n\n  line = line.replace(STRONG_STYLE_REGEX, function (match, subMatch1) {\n    return \"<strong>\" + subMatch1 + \"</strong>\";\n  });\n\n  line = line.replace(EM_STYLE_REGEX, function (match, subMatch1) {\n    return \"<em>\" + subMatch1 + \"</em>\";\n  });\n\n  line = line.replace(LINK_REGEX, function (match, matchedLink) {\n    var underscoreLink = \"\";\n\n    if(matchedLink.indexOf(\"Category:\") === 0){\n      var elem = '<span class=\"category\">';\n      var colonIndex = matchedLink.indexOf(\":\");\n      var category = matchedLink.substring(colonIndex + 1);\n      var link = '<a href=\"' + constants.WIKIPEDIA_EN_URL_WIKI + 'Category:' + category.replace(/\\s/g, \"_\") + '\">' + category + '</a>';\n\n      return elem + link + '</span>';\n    } else if (/\\|/.test(matchedLink)) {\n      //TODO Use underscore to perform trimming\n      var splitLink = matchedLink.split(\"|\");\n      matchedLink = splitLink[1];\n      underscoreLink = splitLink[0].replace(/\\s/g, \"_\");\n    } else {\n      underscoreLink = matchedLink.replace(/\\s/g, \"_\");\n    }\n\n    return '<a href=\"' + constants.WIKIPEDIA_EN_URL + '/wiki/' + underscoreLink + '\">' + matchedLink + '</a>';\n  });\n\n\n  line = line.replace(SINGLE_BRACKET_LINK_REGEX, function(match, matchedLink){\n    if(matchedLink.indexOf(\"http://\") === 0){\n      var firstSpaceIndex = matchedLink.indexOf(\" \");\n      var link = matchedLink.substring(0, firstSpaceIndex);\n      var title = matchedLink.substring(firstSpaceIndex + 1);\n\n      return '<a href=\"' + link + '\">' + title + \"</a>\";\n    }else{\n      return matchedLink;\n    }\n  });\n\n\n  line = line.replace(COMMENTS_REGEX, \"\");\n\n  line = line.replace(SPECIAL_LANGUAGE_INFO_REGEX, function (match, matchedLangStr) {\n    var splitInfo = matchedLangStr.split(\"|\");\n    if (splitInfo.length > 0) {\n      //short circuit rightaway if we are dealing with a citation/reference\n      if (/cite/.test(splitInfo[0])) {\n        return \"\";\n      }\n      var langInfo = LANGUAGE_MAP[splitInfo[0]];\n      var prefix = \"\";\n      var suffix = \"\";\n\n      //Print the language information if it is present\n      if (langInfo) {\n        langInfo = langInfo ? langInfo + \": \" : \"\";\n        prefix = langInfo;\n      } else {\n        prefix = \"[\";\n        suffix = \"]\"\n      }\n      var ret = prefix;\n      for (var i = 1; i < splitInfo.length; ++i) {\n        var curr = splitInfo[i];\n        if (!/links|IPA|icon/.test(curr)) {\n          ret += splitInfo[i];\n        }\n      }\n      ret += suffix;\n      return ret;\n    } else {\n      return \"\";\n    }\n  });\n\n  line = line.replace(REFERENCE_REGEX, function (match, matchedAuthor) {\n    return \"(ref: \" + matchedAuthor + \")\";\n  });\n\n  line = line.replace(REFERENCES_TO_IGNORE, \"\");\n\n  return line;\n}\n\n\nmodule.exports.convertLineToHTML = convertLineToHTML;"]],"start1":0,"start2":0,"length1":0,"length2":6026}]],"length":6026,"saved":false}
